# PagePilot Database Schema Documentation

This document provides a comprehensive overview of the PagePilot database schema, including all tables, relationships, constraints, and design decisions.

## ðŸ—‚ï¸ Database Overview

**Database Type**: SQLite  
**ORM**: Prisma  
**Schema Management**: Prisma Client Generation  
**Connection Pooling**: Built-in Prisma connection pooling  

## ðŸ“Š Entity Relationship Diagram

```mermaid
erDiagram
    Author {
        string id PK "CUID Primary Key"
        string name "Author full name"
        string bio "Author biography"
        int birthYear "Author birth year"
        datetime createdAt "Record creation time"
        datetime updatedAt "Last update time"
    }
    
    Book {
        string id PK "CUID Primary Key"
        string title "Book title"
        string summary "Book description"
        int publicationYear "Year published"
        string authorId FK "References Author.id"
        datetime createdAt "Record creation time"
        datetime updatedAt "Last update time"
    }

    Author ||--o{ Book : "writes"
```

## ðŸ“‹ Table Definitions

### âœï¸ Authors Table (`authors`)

Contains information about book authors.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | String | PRIMARY KEY, CUID | Unique author identifier |
| `name` | String | NOT NULL | Author full name |
| `bio` | String | NOT NULL | Author biography |
| `birthYear` | Integer | NOT NULL | Author birth year |
| `createdAt` | DateTime | DEFAULT now() | Record creation timestamp |
| `updatedAt` | DateTime | AUTO UPDATE | Last modification timestamp |

**Indexes:**
- Primary: `id`

**Relationships:**
- One-to-Many: `books` (Author can write multiple books)

---

### ðŸ“š Books Table (`books`)

Stores book catalog information.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | String | PRIMARY KEY, CUID | Unique book identifier |
| `title` | String | NOT NULL | Book title |
| `summary` | String | NOT NULL | Book description/summary |
| `publicationYear` | Integer | NOT NULL | Year book was published |
| `authorId` | String | FOREIGN KEY, NOT NULL | Reference to authors.id |
| `createdAt` | DateTime | DEFAULT now() | Record creation timestamp |
| `updatedAt` | DateTime | AUTO UPDATE | Last modification timestamp |

**Indexes:**
- Primary: `id`
- Foreign Key: `authorId` â†’ `authors(id)`

**Relationships:**
- Many-to-One: `author` (Book belongs to one author)

**Constraints:**
- CASCADE DELETE: If author is deleted, all their books are deleted

## ðŸ”— Relationship Types

### One-to-Many Relationships

1. **Author â†’ Books** (`1:N`)
   - One author can write multiple books
   - Each book belongs to exactly one author
   - Enforced by foreign key `books.authorId`

## ðŸš¨ Data Integrity Rules

### Primary Keys
- All tables use **CUID** (Collision-resistant Universal Identifier)
- More secure and URL-safe than auto-incrementing integers
- Generated by Prisma using `@default(cuid())`

### Foreign Key Constraints
- `books.authorId` â†’ `authors.id` (CASCADE DELETE)

### Cascade Delete Behavior
- **Delete Author**: All their books are automatically deleted

## ðŸ“ˆ Indexing Strategy

### Primary Indexes
- All `id` fields are automatically indexed (PRIMARY KEY)

### Query Optimization
- Author-Book lookups are optimized via `books.authorId` foreign key index

## ðŸ”§ Schema Definition (Prisma)

```prisma
generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Author {
  id        String   @id @default(cuid())
  name      String
  bio       String
  birthYear Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  books Book[]
  
  @@map("authors")
}

model Book {
  id              String   @id @default(cuid())
  title           String
  summary         String
  publicationYear Int
  authorId        String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  author Author @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@map("books")
}
```

## ðŸ’¾ Sample Data Structure

### Authors
```sql
INSERT INTO authors (id, name, bio, birthYear) VALUES
('clh789...', 'J.K. Rowling', 'British author best known for Harry Potter', 1965),
('clhabc...', 'George Orwell', 'English novelist and social critic', 1903),
('clhdef...', 'Stephen King', 'American author of horror and supernatural fiction', 1947);
```

### Books
```sql
INSERT INTO books (id, title, summary, publicationYear, authorId) VALUES
('clhghi...', 'Harry Potter and the Philosopher''s Stone', 'A young wizard''s journey begins at Hogwarts School of Witchcraft and Wizardry', 1997, 'clh789...'),
('clhjkl...', '1984', 'A dystopian social science fiction novel about totalitarian control', 1949, 'clhabc...'),
('clhmno...', 'The Shining', 'A horror novel about a family''s winter isolation at a haunted hotel', 1977, 'clhdef...');
```

## ðŸ” Common Queries

### Get all books by an author
```sql
SELECT b.* FROM books b 
JOIN authors a ON b.authorId = a.id 
WHERE a.id = 'author_id';
```

### Get author with their books
```sql
SELECT a.*, b.id as book_id, b.title, b.summary, b.publicationYear
FROM authors a
LEFT JOIN books b ON a.id = b.authorId
WHERE a.id = 'author_id';
```

### Search books by title
```sql
SELECT b.*, a.name as author_name 
FROM books b
JOIN authors a ON b.authorId = a.id
WHERE b.title LIKE '%search_term%';
```

### Get authors with book count
```sql
SELECT a.*, COUNT(b.id) as book_count
FROM authors a
LEFT JOIN books b ON a.id = b.authorId
GROUP BY a.id;
```

## ðŸ” Prisma Query Examples

### Create Author with Books
```typescript
const authorWithBooks = await prisma.author.create({
  data: {
    name: 'J.K. Rowling',
    bio: 'British author best known for Harry Potter',
    birthYear: 1965,
    books: {
      create: [
        {
          title: 'Harry Potter and the Philosopher\'s Stone',
          summary: 'A young wizard\'s journey begins',
          publicationYear: 1997,
        },
        {
          title: 'Harry Potter and the Chamber of Secrets',
          summary: 'Harry\'s second year at Hogwarts',
          publicationYear: 1998,
        },
      ],
    },
  },
  include: {
    books: true,
  },
});
```

### Get Author with Books
```typescript
const authorWithBooks = await prisma.author.findUnique({
  where: { id: 'author_id' },
  include: { books: true },
});
```

### Get All Books with Authors
```typescript
const booksWithAuthors = await prisma.book.findMany({
  include: { author: true },
  orderBy: { createdAt: 'desc' },
});
```

### Get Books by Author ID
```typescript
const booksByAuthor = await prisma.book.findMany({
  where: { authorId: 'author_id' },
  include: { author: true },
  orderBy: { publicationYear: 'desc' },
});
```

## ðŸš€ Performance Considerations

### Database Connections
- Using Prisma connection pooling (default: 13 connections for SQLite)
- Connections automatically managed by Prisma Client

### Query Optimization
- Foreign key indexes provide fast joins between authors and books
- CUID primary keys are indexed by default
- SQLite performs well for read-heavy workloads

### Scalability Notes
- Current schema supports thousands of authors and books efficiently
- SQLite is suitable for development and small to medium production loads
- Can be migrated to PostgreSQL for larger scale deployments

## ðŸ”’ Security Features

### Data Validation
- Foreign key constraints prevent orphaned records
- NOT NULL constraints ensure required fields are present
- Prisma provides SQL injection protection through parameterized queries

### Access Control
- Database access controlled via environment variables
- Prisma client provides type-safe database operations
- No raw SQL exposure in application code

## ðŸ§ª Testing & Development

### Development Database
- SQLite file stored locally (`prisma/dev.db`)
- Fast setup and teardown for testing
- No external database dependencies required

### Data Management Commands
```bash
npm run db:generate  # Generate Prisma client
npm run db:push     # Push schema changes to database
npm run db:migrate  # Create and run migrations (for production)
```

### Test Data Cleanup
```typescript
beforeEach(async () => {
  await prisma.book.deleteMany();
  await prisma.author.deleteMany();
});
```

## ðŸ”§ Environment Configuration

### Database URL Configuration
```bash
# Development (SQLite)
DATABASE_URL="file:./dev.db"

# Production (PostgreSQL example)
DATABASE_URL="postgresql://user:password@localhost:5432/pagepilot"
```

### Prisma Configuration
```typescript
export const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});
```